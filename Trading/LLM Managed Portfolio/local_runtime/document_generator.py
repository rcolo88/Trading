"""
Document Generator for Local LLM Analysis
Converts LLM pipeline analysis results into standard trading_recommendation_*.md format

Located in local_runtime/ to work with copied portfolio system.
Ensures seamless compatibility with existing TradeExecutor document parsing.
"""

import os
import sys
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass

# Add the Portfolio Scripts Schwab directory to the path
current_dir = os.path.dirname(os.path.abspath(__file__))
portfolio_dir = os.path.join(current_dir, 'Portfolio Scripts Schwab')
sys.path.append(portfolio_dir)

from llm_analysis_pipeline import PipelineResult, AnalysisResult
from trading_models import TradeOrder, OrderType, OrderPriority
from portfolio_manager import PortfolioManager


@dataclass
class DocumentGenerationConfig:
    """Configuration for document generation"""
    include_risk_management: bool = True
    include_market_analysis: bool = True
    include_detailed_rationale: bool = True
    max_orders_per_priority: int = 10
    output_directory: str = None
    filename_prefix: str = "trading_recommendation_local"


class DocumentGenerator:
    """Generates standard trading recommendation documents from LLM analysis"""
    
    def __init__(self, portfolio_manager: PortfolioManager, config: DocumentGenerationConfig = None):
        """
        Initialize document generator
        
        Args:
            portfolio_manager: Portfolio state for context
            config: Document generation configuration
        """
        self.portfolio = portfolio_manager
        self.config = config or DocumentGenerationConfig()
        
        # Set default output directory to parent directory (main project directory)
        if not self.config.output_directory:
            self.config.output_directory = os.path.join(current_dir, '..')
    
    def generate_recommendation_document(self, pipeline_result: PipelineResult, 
                                       save_to_file: bool = True) -> Tuple[str, str]:
        """
        Generate complete trading recommendation document
        
        Args:
            pipeline_result: Complete LLM pipeline analysis result
            save_to_file: Whether to save document to file
            
        Returns:
            Tuple of (document_content, file_path)
        """
        
        # Generate document content
        document_content = self._build_document_content(pipeline_result)
        
        file_path = None
        if save_to_file:
            file_path = self._save_document(document_content)
        
        return document_content, file_path
    
    def _build_document_content(self, pipeline_result: PipelineResult) -> str:
        """Build the complete document content following the standard template"""
        
        current_date = datetime.now().strftime('%Y-%m-%d')
        timestamp = datetime.now().strftime('%H:%M:%S')
        
        # Build document sections
        header = self._build_header_section(pipeline_result, current_date)
        risk_management = self._build_risk_management_section(pipeline_result)
        orders = self._build_orders_section(pipeline_result)
        market_analysis = self._build_market_analysis_section(pipeline_result)
        strategic_allocation = self._build_strategic_allocation_section(pipeline_result)
        execution_notes = self._build_execution_notes_section(pipeline_result)
        
        # Combine all sections
        document = f"""# ü§ñ LLM Trading Recommendations - Local Analysis

**Generated by Local LLM Pipeline at {timestamp}**

---

{header}

---

{risk_management}

---

{orders}

{market_analysis}

{strategic_allocation}

{execution_notes}

---

## üîÑ PIPELINE EXECUTION SUMMARY

**Analysis Models Used:**
- News Analysis: {'‚úÖ' if pipeline_result.news_analysis else '‚ùå'}
- Market Analysis: {'‚úÖ' if pipeline_result.market_analysis else '‚ùå'}  
- Trading Decision: {'‚úÖ' if pipeline_result.trading_decision else '‚ùå'}
- Risk Validation: {'‚úÖ' if pipeline_result.risk_validation else '‚ùå'}

**Confidence Score:** {pipeline_result.confidence_score:.1%}
**Processing Time:** {pipeline_result.processing_time:.1f}s
**Total Recommendations:** {len(pipeline_result.final_recommendations)}

{'**Warnings:**' if pipeline_result.warnings else ''}
{chr(10).join(f'- {warning}' for warning in pipeline_result.warnings) if pipeline_result.warnings else ''}

---

*Generated by Local LLM Analysis Pipeline - {pipeline_result.timestamp}*
"""
        
        return document
    
    def _build_header_section(self, pipeline_result: PipelineResult, date: str) -> str:
        """Build document header section"""
        
        # Extract market conditions from analysis
        market_conditions = "Local LLM analysis based on current portfolio state and market data"
        if pipeline_result.market_analysis and pipeline_result.market_analysis.key_insights:
            market_conditions = pipeline_result.market_analysis.key_insights[0][:200] + "..."
        
        # Extract portfolio performance summary
        portfolio_performance = f"Portfolio analysis completed at {date}"
        if pipeline_result.trading_decision and pipeline_result.trading_decision.key_insights:
            perf_insights = [insight for insight in pipeline_result.trading_decision.key_insights 
                           if any(keyword in insight.lower() for keyword in ['return', 'performance', '%'])]
            if perf_insights:
                portfolio_performance = perf_insights[0][:200] + "..."
        
        return f"""## üìÖ DOCUMENT HEADER
*Date: {date}*  
*Market Conditions: {market_conditions}*  
*Portfolio Performance: {portfolio_performance}*"""
    
    def _build_risk_management_section(self, pipeline_result: PipelineResult) -> str:
        """Build risk management updates section"""
        
        risk_updates = []
        position_adjustments = []
        
        # Extract risk insights from analysis
        if pipeline_result.risk_validation and pipeline_result.risk_validation.key_insights:
            risk_insights = pipeline_result.risk_validation.key_insights
            
            # Generate dynamic risk parameters
            for insight in risk_insights[:5]:
                if 'stop' in insight.lower() or 'loss' in insight.lower():
                    risk_updates.append(f"**UPDATE STOP-LOSS** - {insight}")
                elif 'cash' in insight.lower() or 'reserve' in insight.lower():
                    risk_updates.append(f"**CASH-RESERVE** - {insight}")
                elif 'concentration' in insight.lower() or 'position' in insight.lower():
                    risk_updates.append(f"**MAX-POSITION-SIZE** - {insight}")
                else:
                    risk_updates.append(f"**RISK-PARAMETER** - {insight}")
        
        # Extract position-specific adjustments from trading analysis
        if pipeline_result.trading_decision and pipeline_result.trading_decision.key_insights:
            for insight in pipeline_result.trading_decision.key_insights[:5]:
                if any(ticker in insight for ticker in ['NVDA', 'AAPL', 'GOOGL', 'AMD', 'QS', 'IONS']):
                    position_adjustments.append(f"**POSITION ADJUSTMENT** - {insight}")
        
        # Default risk parameters if no specific insights
        if not risk_updates:
            risk_updates = [
                "**MAX-POSITION-SIZE 20%** - Maintain individual position limits for risk management",
                "**CASH-RESERVE 5%** - Minimum cash buffer for market volatility",
                "**RISK-BUDGET MODERATE** - Balanced approach given current market conditions"
            ]
        
        if not position_adjustments:
            position_adjustments = [
                "**PORTFOLIO REBALANCING** - Monitor position weights and rebalance as needed",
                "**STOP-LOSS REVIEW** - Regular review of stop-loss levels based on volatility"
            ]
        
        risk_section = "## üõ°Ô∏è RISK MANAGEMENT UPDATES\n\n"
        risk_section += "### ‚öôÔ∏è Dynamic Risk Parameters\n"
        risk_section += "\n".join(risk_updates)
        risk_section += "\n\n### üéØ Position-Specific Risk Adjustments\n"
        risk_section += "\n".join(position_adjustments)
        
        return risk_section
    
    def _build_orders_section(self, pipeline_result: PipelineResult) -> str:
        """Build orders section with proper priority grouping"""
        
        orders_section = "## üìã ORDERS SECTION\n\n"
        
        # Group orders by priority
        high_priority_orders = []
        medium_priority_orders = []
        low_priority_orders = []
        
        for order in pipeline_result.final_recommendations:
            order_text = self._format_order_command(order)
            
            if order.priority == OrderPriority.HIGH:
                high_priority_orders.append(order_text)
            elif order.priority == OrderPriority.LOW:
                low_priority_orders.append(order_text)
            else:
                medium_priority_orders.append(order_text)
        
        # Build priority sections
        if high_priority_orders:
            orders_section += "### üî• IMMEDIATE EXECUTION (HIGH PRIORITY)\n\n"
            orders_section += "\n\n".join(high_priority_orders[:self.config.max_orders_per_priority])
            orders_section += "\n\n"
        
        if medium_priority_orders:
            orders_section += "### ‚öñÔ∏è POSITION MANAGEMENT (MEDIUM PRIORITY)\n\n"
            orders_section += "\n\n".join(medium_priority_orders[:self.config.max_orders_per_priority])
            orders_section += "\n\n"
        
        if low_priority_orders:
            orders_section += "### üìà STRATEGIC POSITIONING (LOW PRIORITY)\n\n"
            orders_section += "\n\n".join(low_priority_orders[:self.config.max_orders_per_priority])
            orders_section += "\n\n"
        
        # Add fallback if no orders
        if not any([high_priority_orders, medium_priority_orders, low_priority_orders]):
            orders_section += "### üìä PORTFOLIO MAINTENANCE\n\n"
            orders_section += "**HOLD ALL POSITIONS** - No changes recommended at this time based on current analysis\n\n"
        
        return orders_section
    
    def _format_order_command(self, order: TradeOrder) -> str:
        """Format individual order in the expected command format"""
        
        # Format the basic command
        shares_text = f"{order.shares} shares of" if order.shares else ""
        command = f"**{order.action.value} {shares_text} {order.ticker}**"
        
        # Add reason if provided
        if order.reason:
            command += f" - {order.reason}"
        
        # Add target value if specified
        if order.target_value:
            command += f" (Target: ${order.target_value:,.2f})"
        
        return command
    
    def _build_market_analysis_section(self, pipeline_result: PipelineResult) -> str:
        """Build market analysis and rationale section"""
        
        market_section = "## MARKET ANALYSIS & RATIONALE\n\n"
        
        # Current Market Environment
        market_environment = "Market analysis based on local LLM assessment of current conditions."
        if pipeline_result.market_analysis and pipeline_result.market_analysis.analysis_text:
            # Extract first substantial paragraph
            paragraphs = pipeline_result.market_analysis.analysis_text.split('\n\n')
            substantial_paragraphs = [p.strip() for p in paragraphs if len(p.strip()) > 100]
            if substantial_paragraphs:
                market_environment = substantial_paragraphs[0][:500] + "..."
        
        market_section += "### Current Market Environment\n"
        market_section += market_environment + "\n\n"
        
        # Risk Assessment
        risk_assessment = "Portfolio risk assessment based on local LLM analysis."
        if pipeline_result.risk_validation and pipeline_result.risk_validation.analysis_text:
            # Extract risk-focused content
            risk_text = pipeline_result.risk_validation.analysis_text
            risk_paragraphs = [p.strip() for p in risk_text.split('\n\n') if len(p.strip()) > 50]
            if risk_paragraphs:
                risk_assessment = risk_paragraphs[0][:400] + "..."
        
        market_section += "### Risk Assessment\n"
        market_section += risk_assessment + "\n\n"
        
        # Performance Attribution
        performance_attribution = "Performance analysis based on current portfolio positions."
        if pipeline_result.trading_decision and pipeline_result.trading_decision.analysis_text:
            # Look for performance-related content
            trading_text = pipeline_result.trading_decision.analysis_text.lower()
            if 'performance' in trading_text or 'return' in trading_text:
                sentences = pipeline_result.trading_decision.analysis_text.split('.')
                perf_sentences = [s.strip() for s in sentences if 
                                any(keyword in s.lower() for keyword in ['performance', 'return', 'gain', 'loss'])]
                if perf_sentences:
                    performance_attribution = '. '.join(perf_sentences[:3]) + "."
        
        market_section += "### Performance Attribution\n"
        market_section += performance_attribution + "\n\n"
        
        return market_section
    
    def _build_strategic_allocation_section(self, pipeline_result: PipelineResult) -> str:
        """Build strategic allocation targets section"""
        
        return """## STRATEGIC ALLOCATION TARGETS

### Target Portfolio Composition
- **Growth/Momentum**: 40%
- **Value/Cyclical**: 15%
- **Defensive/Quality**: 20%
- **Speculative/Catalyst**: 10%
- **Cash Reserve**: 15%

### Sector Allocation Targets
- **Technology**: 35%
- **Healthcare/Biotech**: 20%
- **Financial**: 10%
- **Energy**: 10%
- **Consumer**: 10%
- **Other/International**: 15%
"""
    
    def _build_execution_notes_section(self, pipeline_result: PipelineResult) -> str:
        """Build execution notes section"""
        
        # Calculate estimated cash flows from recommendations
        total_buy_orders = len([o for o in pipeline_result.final_recommendations if o.action == OrderType.BUY])
        total_sell_orders = len([o for o in pipeline_result.final_recommendations if o.action == OrderType.SELL])
        
        execution_notes = f"""## EXECUTION NOTES

### Cash Flow Management
Recommended trades include {total_buy_orders} BUY orders and {total_sell_orders} SELL orders. Prioritize risk management orders first, followed by rebalancing trades. Maintain minimum 5% cash reserve for market volatility.

### Timing Considerations
Execute high-priority orders during market hours with adequate volume. Monitor for significant market movements that might affect execution prices. Consider partial fills for large positions.

### Partial Fill Instructions
**Partial Fill Mode**: {self.portfolio.partial_fill_mode.value}
- HIGH priority: Execute regardless of partial fills
- MEDIUM priority: Accept partial fills above 50%
- LOW priority: Prefer full fills, accept partials above 75%

### Risk Monitoring
Monitor position sizes after execution to ensure compliance with risk limits. Set alerts for stop-loss triggers and review positions if market volatility increases significantly.
"""
        
        return execution_notes
    
    def _save_document(self, document_content: str) -> str:
        """Save document to file with appropriate naming"""
        
        # Generate filename
        timestamp = datetime.now().strftime('%m%d%y_%H%M')
        filename = f"{self.config.filename_prefix}_{timestamp}.md"
        file_path = os.path.join(self.config.output_directory, filename)
        
        try:
            # Ensure output directory exists
            os.makedirs(self.config.output_directory, exist_ok=True)
            
            # Write document
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(document_content)
            
            print(f"‚úÖ Trading recommendation document saved: {filename}")
            return file_path
            
        except Exception as e:
            print(f"‚ùå Error saving document: {e}")
            return None
    
    def validate_document_format(self, document_content: str) -> Dict[str, Any]:
        """Validate that generated document follows expected format"""
        
        validation_results = {
            "has_orders_section": "## üìã ORDERS SECTION" in document_content,
            "has_risk_section": "## üõ°Ô∏è RISK MANAGEMENT" in document_content,
            "has_market_analysis": "## MARKET ANALYSIS" in document_content,
            "has_valid_commands": False,
            "command_count": 0,
            "format_score": 0.0
        }
        
        # Check for valid trading commands
        command_patterns = [
            r'\*\*BUY\s+\d*\s*shares?\s+of\s+[A-Z]+\*\*',
            r'\*\*SELL\s+\d*\s*shares?\s+of\s+[A-Z]+\*\*',
            r'\*\*HOLD\s+.*[A-Z]+\*\*'
        ]
        
        import re
        command_count = 0
        for pattern in command_patterns:
            matches = re.findall(pattern, document_content, re.IGNORECASE)
            command_count += len(matches)
        
        validation_results["has_valid_commands"] = command_count > 0
        validation_results["command_count"] = command_count
        
        # Calculate format score
        score = 0
        score += 25 if validation_results["has_orders_section"] else 0
        score += 25 if validation_results["has_risk_section"] else 0
        score += 25 if validation_results["has_market_analysis"] else 0
        score += 25 if validation_results["has_valid_commands"] else 0
        
        validation_results["format_score"] = score
        
        return validation_results


# Utility function for standalone document generation
def generate_document_from_pipeline(pipeline_result: PipelineResult, 
                                   portfolio_manager: PortfolioManager,
                                   save_to_file: bool = True) -> Tuple[str, str]:
    """
    Standalone utility to generate document from pipeline result
    
    Args:
        pipeline_result: LLM pipeline analysis result
        portfolio_manager: Portfolio manager instance
        save_to_file: Whether to save to file
        
    Returns:
        Tuple of (document_content, file_path)
    """
    
    generator = DocumentGenerator(portfolio_manager)
    return generator.generate_recommendation_document(pipeline_result, save_to_file)


if __name__ == "__main__":
    print("üìÑ Document Generator - Standalone testing not implemented")
    print("Use generate_document_from_pipeline() for testing with real pipeline results")